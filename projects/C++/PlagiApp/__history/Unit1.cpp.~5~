//---------------------------------------------------------------------------

#include <fstream>
#include <vector>
#include <vcl.h>
#include <string>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#pragma hdrstop

#include "Unit1.h"
#include "Unit2.h"
#include "Unit3.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
using namespace std;
TForm1 *Form1;

int Counter = 0, Count_Programs = 0, Current_Program = 0, Best_Coincidence[4] = {-1,-1,-1,-1};
string Obrazec_Operator = "~:&|^.,()[]{}!=<>+-*/%"; ///Образцы операторов
string Code[2]; ///Коды программ
double ur_plagiat[4] = {0,0,0,0}; ///Уровень плагиата
vector <string> function_types, inv_function_types, Fword_types, Operator_types, functions[2], h_str[2], el; ///Образцы типов функций/служебных слов(СС) и пофункциональные записи СС
double coincidence, total_coincidence[4]; ///Совпадение по методу токенизации
vector <int> hash_str;
int st_70[5] = {1, 70, 4900, 343000, 24010000};

String Directory;
string forms[9];
vector <string> sendings;
String main_FileName = Directory + "\\Sendings.txt";
ifstream fin(main_FileName.c_str());

void Sozdanie()
{
	forms[0] = "ИМ"; forms[1] = "М"; forms[2] = "Ф";
	forms[3] = "ФМ"; forms[4] = "БИО"; forms[5] = "ИСТ";
	forms[6] = "ФИЛ"; forms[7] = "ХБ"; forms[8] = "ХИМ";
	Form1->Series1->Clear();
	Form1->Series2->Clear();
	sendings.clear();
	String init_FileName = Directory + "\\initialization.txt";
	ifstream f_in(init_FileName.c_str());
	f_in >> Count_Programs;
	string temp;
	for(int i = 0; i < Count_Programs; i++)
	{
		getline(fin, temp);
		sendings.push_back(temp.substr(0, temp.find(' ')));
	}
	Form1->StringGrid1->RowCount = Count_Programs+1;
	Form1->StringGrid1->Cells[0][0]="№";
	Form1->StringGrid1->Cells[1][0]="Класс";
	Form1->StringGrid1->Cells[2][0]="Фамилия";
	Form1->StringGrid1->Cells[3][0]="id программы";
	Form1->StringGrid1->Cells[4][0]="% плагиата";
	Form1->StringGrid1->Cells[5][0]="id копии";
	///Создание массивов образцов служебных слов
	string a = "int float long short double void bool char string ";
	while(a.size()>0)
	{
		function_types.push_back(a.substr(0,a.find(' ')));
		a.erase(0,a.find(' ')+1);
    }
	a = "INT FLOAT LONG SHORT DOUBLE VOID BOOL CHAR STRING ";
    while(a.size()>0)
    {
        inv_function_types.push_back(a.substr(0,a.find(' ')));
        a.erase(0,a.find(' ')+1);
	}
    a = "int float long short double void bool char struct class for while if else string global new delete return do continue const ";
    while(a.size()>0)
    {
		Fword_types.push_back(a.substr(0,a.find(' ')));
        a.erase(0,a.find(' ')+1);
    }
    a = "++ -- () [] -> .* ->* << >> <= >= == != && || += -= *= /= %= <<= >>= &= |= ^= :: ";
    while(a.size()>0)
    {
        Operator_types.push_back(a.substr(0,a.find(' ')));
        a.erase(0,a.find(' ')+1);
    }
}

inline void Proverka (int in) ///Проверка по методу токенизации
{
    if ((in==0)||(in==1))
    {
        if ((total_coincidence[in]*100)/functions[0].size() > ur_plagiat[in])
        {
            ur_plagiat[in] = (total_coincidence[in]*100)/functions[0].size();
            Best_Coincidence[in] = Current_Program;
        }
    }
    else
        if ((total_coincidence[in]*100)/h_str[0].size() > ur_plagiat[in])
        {
            ur_plagiat[in] = (total_coincidence[in]*100)/h_str[0].size();
            Best_Coincidence[in] = Current_Program;
        }
}

inline double Compare (string smax, string smin, int var)
{
    int i, j, p, n, kod = smax.size();
    coincidence = 0;
    double kol, Max_kol;
    if(smax.size() < smin.size())
        swap(smax,smin);
    smax+=smax;
    n = smin.size();
    if(var == 0)
		for(i = 0; i < (smax.size())/2; i++)
        {
            kol = 0;
            for(j = 0; j < n; j++)
                if(smin[j] == smax[j+i])
                    kol++;
            if (kol/kod > coincidence)
                coincidence = kol/kod;
        }
    else
        for(i = 0; i < (smax.size())/2; i++)
        {
            kol = 0;
            p = 0;
            Max_kol = 0;
            for(j = 0; j < n; j++)
                if(smin[j] == smax[j+i])
                {
                    kol++;
                    p = 1;
                }
                else if(p == 1)
                {
                    p = 0;
                    if(kol > Max_kol)
                        Max_kol = kol;
                    kol = 0;
                }
            if(p == 1)
                if(kol > Max_kol)
                    Max_kol = kol;
            if (Max_kol/kod > coincidence)
                coincidence = Max_kol/kod;
        }
    return coincidence;
}

inline void Rabota_Functions (int var) ///Сравнение программ
{
    int i, j;
    double coin, Max;
    coincidence = 0;
    total_coincidence[var] = 0;
    for (i = 0; i < functions[0].size(); i++)
    {
        Max = 0;
        for (j = 0; j < functions[1].size(); j++)
        {
            if (functions[0][i][0] == functions[1][j][0])
            {
                if ((var==0)||(var==1))
                    coin = Compare(functions[0][i],functions[1][j],var);
                else
                    coin = Compare(h_str[0][i],h_str[1][j],var);
                if(coin > Max)
                    Max = coin;
            }
        }
        total_coincidence[var] += Max;
    }
    Proverka(var);
}

inline int Baza_Hash (char c)
{
    if ((c>64)&&(c<87))
        return c-64;
    else if((c>96)&&(c<123))
        return c-96+22;
    else
        return Obrazec_Operator.find(c)+49;
}

inline string Winnowing ()
{
    int w = 2, sign, last;
    string marks;
    for(int i = w - 1; i < hash_str.size(); i++)
    {
        if(hash_str[i] <= hash_str[i-1])
            sign = i;
        else
            sign = i-1;
        if(sign != last)
            marks += el[sign];
        last = sign;
    }
    return marks;
}

inline void Hash (string str)
{
    int i, j, x, n = str.size()-2, rezultat;
	hash_str.clear();
    el.clear();
	for (i = 0; i < n; i++)
    {
		el.push_back(str.substr(i, 3));
        rezultat = 0;
        for (j = 0; j < 3; j++)
		{
            x = Baza_Hash(el[i][j]);
            rezultat += x*st_70[j];
        }
        hash_str.push_back(rezultat);
    }
    h_str[0].push_back(Winnowing());
}

inline void Hashing ()
{
    for (int i = 0; i < functions[0].size(); i++)
        Hash(functions[0][i]);
}

inline void Find_operators (string str, int kod) ///Запись последовательностей операторов программ
{
    string posl;
    int position;
    for(int i = 0; i < str.size(); i++)
        posl += ' ';
    for(int j = 0; j < Fword_types.size(); j++)
    {
        while(str.find(Fword_types[j])!=string::npos)
        {
            position = str.find(Fword_types[j]);
            posl[position] = 'A' + j;
            str.erase(position, Fword_types[j].size());
            for(int i = 0; i < Fword_types[j].size(); i++)
                str.insert(position, " ");
        }
    }
    for(int j = 0; j < Operator_types.size(); j++)
    {
        while(str.find(Operator_types[j])!=string::npos)
        {
            position = str.find(Operator_types[j]);
            posl[position] = 'a' + j;
            str.erase(position, Operator_types[j].size());
            for(int i = 0; i < Operator_types[j].size(); i++)
                str.insert(position, " ");
        }
    }
    for(int j = 0; j < Obrazec_Operator.size(); j++)
    {
        while(str.find(Obrazec_Operator[j])!=string::npos)
        {
            position = str.find(Obrazec_Operator[j]);
            posl[position] = Obrazec_Operator[j];
            str.erase(position, 1);
            str.insert(position, " ");
        }
    }
    while(posl.find(' ')!=string::npos)
        posl.erase(posl.find(' '),1);
    functions[kod].push_back(posl);
}

inline void Find_function (int kod)    ///Пофункцинальная токенизация программ
{
    string str = Code[kod];
    for(int j = 0; j < function_types.size(); j++)
    {
        while(str.find(function_types[j])!=string::npos)
        {
            int Fword_pos = str.find(function_types[j]);
            int pos, first = 0;
            for(pos = Fword_pos+1; pos < str.size(); pos++)
                if(str[pos] == '(' && pos != (Fword_pos+function_types[j].size()))   ///Поиск открывающей скобки после типа функции/переменной
                {
                    first = 1;
                    break;
                }
                else if(str[pos] == ';' || str[pos] == ',' || str[pos] == ')' || str[pos] == '=')  ///Поиск точки с запятой после типа функции/переменной
                    break;
            if(first == 1) ///Если это функция
            {
                int End;
                int p = 0;
                for(int i = pos+1; i < str.size(); i++)
                    if(str[i] == '}')
                    {
                        p--;
                        if(p == 0)
                        {
                            End = i;
                            break;
                        }
                    }
                    else if(str[i] == '{')
                        p++;
                string func = str.substr(Fword_pos, End-Fword_pos+1); ///Выделение тела функции
                str.erase(Fword_pos,End-Fword_pos+1);
                Find_operators(func, kod);
            }
            else
            {
                for(int i = Fword_pos; i < Fword_pos + inv_function_types[j].size(); i++)
                    str[i]-=32;
            }
        }
        while(str.find(inv_function_types[j])!=string::npos)
        {
            int inv_pos = str.find(inv_function_types[j]);
            for(int i = inv_pos; i < inv_pos + inv_function_types[j].size(); i++)
                str[i]+=32;
        }
	}
}

//---------------------------------------------------------------------------
__fastcall TForm1::TForm1(TComponent* Owner)
	: TForm(Owner)
{
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Button1Click(TObject *Sender)
{
	Sozdanie();
	Series1->Add(0,"",clAqua);
	StringGrid1->ColWidths[0] = 50;
	StringGrid1->ColWidths[1] = 100;
	StringGrid1->ColWidths[2] = 200;
	StringGrid1->ColWidths[3] = 150;
	StringGrid1->ColWidths[4] = 150;
	StringGrid1->ColWidths[5] = 150;
	vector <int> plag_value (101, 0);
	DirectoryListBox1->Visible = false;
	String FileName = Directory + "\\off.txt";
	ofstream fout (FileName.c_str());
	string Code_dop, temp_string;
	String n1, n2;
	int func_size;
	int i, j, k;
	for(Counter = 0; Counter < Count_Programs; Counter++)
	{
		Code[0] = "";
		functions[0].clear();
		h_str[0].clear();
		n1 = "\\(";
		n1 += sendings[Counter].c_str();
		n1 += ").cpp";
		FileName = Directory + n1;
		ifstream fin1 (FileName.c_str());
		/// Ввод кодов программ
		while(!fin1.eof())
		{
			getline(fin1, Code_dop);
			while(Code_dop.find('\t')!=string::npos)
			{
				Code_dop.erase(Code_dop.find('\t'),1);
			}
			while(Code_dop.find(' ')!=string::npos)
			{
				Code_dop.erase(Code_dop.find(' '),1);
			}
			if(Code_dop.find("//")!=string::npos)
			{
                k = Code_dop.find("//");
				Code_dop.erase(k, Code_dop.size()-k);
			}
			if(Code_dop.find('"')!=string::npos)
			{
				k = Code_dop.find('"');
				Code_dop.erase(k, 1);
                Code_dop.erase(k, Code_dop.find('"')-k+1);
			}
			if(Code_dop.find("'")!=string::npos)
			{
				k = Code_dop.find("'");
				Code_dop.erase(k, 1);
				Code_dop.erase(k, Code_dop.find("'")-k+1);
			}
			if(Code_dop.find("using namespace std;")!=string::npos)
			{
				int k = Code_dop.find("using namespace std;");
				Code_dop.erase(k, 20);
			}
			Code[0]+=Code_dop;
        }
        Find_function(0);
		n2 = "\\(" + IntToStr(Counter+1) + ").txt";
		FileName = Directory + n2;
		ofstream fout2 (FileName.c_str());
		fout2 << functions[0].size() << endl;
		for(int i = 0; i < functions[0].size(); i++)
			fout2 << functions[0][i] << endl;
		Hashing();
		for(int i = 0; i < h_str[0].size(); i++)
			fout2 << h_str[0][i] << endl;
	}
	for(Counter = 0; Counter < Count_Programs; Counter++)
	{
		Code[0] = "";
		functions[0].clear();
		for (i = 0; i < 4; i++)
		{
			ur_plagiat[i] = 0;
		}
		h_str[0].clear();
		n1 = "\\(";
		n1 += sendings[Counter].c_str();
		n1 += ").txt";
		FileName = Directory + n1;
		ifstream fin1 (FileName.c_str());
        fin1 >> func_size;
		for(i = 0; i < func_size; i++)
		{
			fin1 >> temp_string;
			functions[0].push_back(temp_string);
		}
		for(i = 0; i < func_size; i++)
		{
			fin1 >> temp_string;
			h_str[0].push_back(temp_string);
		}
		for(Current_Program = 0; Current_Program < Count_Programs; Current_Program++)
			if(Counter != Current_Program)
			{
				Code[1] = "";
				functions[1].clear();
				h_str[1].clear();
				n2 = "\\(";
				n2 += sendings[Counter].c_str();
				n2 += ").txt";
				FileName = Directory + n2;
				ifstream fin2 (FileName.c_str());
				fin2 >> func_size;
				for(i = 0; i < func_size; i++)
				{
					fin2 >> temp_string;
					functions[1].push_back(temp_string);
				}
				for(i = 0; i < func_size; i++)
				{
					fin2 >> temp_string;
					h_str[1].push_back(temp_string);
				}
				///Сравнение программ
				for (i = 0; i < 4; i++)
					Rabota_Functions(i);
			}
		int Resultat = (int((ur_plagiat[0] * SpinEdit1->Value + ur_plagiat[1] * SpinEdit2->Value + ur_plagiat[2] * SpinEdit3->Value + ur_plagiat[3] * SpinEdit4->Value) / (SpinEdit1->Value + SpinEdit2->Value + SpinEdit3->Value + SpinEdit4->Value)));
		fout << Counter+1 << " " << Resultat << " " << Best_Coincidence[0] + 1 << endl;
		// reading sending's information
		StringGrid1->Cells[0][Counter+1] = IntToStr(Counter+1);
		int form, form_type, form_n, id;
		string name, surname;
		StringGrid1->Cells[1][Counter+1] = IntToStr(form) + ' ' + forms[form_type].c_str() + ' ' + IntToStr(form_n);
		StringGrid1->Cells[2][Counter+1] = (surname + ' ' + name).c_str();
		StringGrid1->Cells[3][Counter+1] = id;
		StringGrid1->Cells[4][Counter+1] = IntToStr(Resultat);
		StringGrid1->Cells[5][Counter+1] = IntToStr(Best_Coincidence[0] + 1);
		//
		Series1->Add(double(Resultat),"",clAqua);
		plag_value[Resultat]++;
	}
	k = 0;
	for(i = 1; i <= 100; i++)
		if(plag_value[i] != 0)
			k++;
	int CurColor[2] = {55,255};
	int di = 200. / k;
	for(i = 0; i <= 100; i++)
	{
		  Series2->Add(plag_value[i], "", RGB(CurColor[0], CurColor[1], 55));
		  if(plag_value[i] != 0)
		  {
			CurColor[0] += di;
			CurColor[1] -= di;
		  }
	}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::DirectoryListBox1Change(TObject *Sender)
{
	Directory = DirectoryListBox1->Directory;
	Button1->Enabled = true;
	DirectoryListBox1->Visible = false;
	DirectoryListBox1->Enabled = false;
}
//---------------------------------------------------------------------------
void __fastcall TForm1::N2Click(TObject *Sender)
{
	DirectoryListBox1->Visible = true;
	DirectoryListBox1->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TForm1::FormCloseQuery(TObject *Sender, bool &CanClose)
{
	if (MessageDlg("Выйти?", mtConfirmation, TMsgDlgButtons() << mbYes << mbNo,0) == mrNo)
	{
		CanClose = false;
	}
}
//---------------------------------------------------------------------------

void __fastcall TForm1::CheckBox1Click(TObject *Sender)
{
	if (CheckBox1->Checked)
	{
		SpinEdit1->Enabled = true;
	}
	else
	{
		SpinEdit1->Enabled = false;
		SpinEdit1->Value = 0;
	}
}
//---------------------------------------------------------------------------

void __fastcall TForm1::CheckBox2Click(TObject *Sender)
{
	if (CheckBox2->Checked)
	{
		SpinEdit2->Enabled = true;
	}
	else
	{
		SpinEdit2->Enabled = false;
		SpinEdit2->Value = 0;
	}
}
//---------------------------------------------------------------------------

void __fastcall TForm1::CheckBox3Click(TObject *Sender)
{
	if (CheckBox3->Checked)
	{
		SpinEdit3->Enabled = true;
	}
	else
	{
		SpinEdit3->Enabled = false;
		SpinEdit3->Value = 0;
	}
}
//---------------------------------------------------------------------------

void __fastcall TForm1::CheckBox4Click(TObject *Sender)
{
	if (CheckBox4->Checked)
	{
		SpinEdit4->Enabled = true;
	}
	else
	{
		SpinEdit4->Enabled = false;
		SpinEdit4->Value = 0;
	}
}
//---------------------------------------------------------------------------

void __fastcall TForm1::N5Click(TObject *Sender)
{
	Form2->Show();
}
//---------------------------------------------------------------------------

void __fastcall TForm1::N6Click(TObject *Sender)
{
	Form3->Show();
}
//---------------------------------------------------------------------------

